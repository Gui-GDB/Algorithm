## 单调栈

- ##### [视频讲解](https://www.bilibili.com/video/BV1VN411J7S7/?vd_source=c2e5218acfbe25abdcd1b5b4b6f7f796)

## [岛屿类问题的通用解法、DFS遍历框架](https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-/?envType=study-plan-v2&envId=top-interview-150)

- [LeetCode第200题](https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-interview-150)
- [LeetCode第463题](https://leetcode.cn/problems/island-perimeter/description/)

- [LeetCode第695题](https://leetcode.cn/problems/max-area-of-island/description/)

- [LeetCode第827题](https://leetcode.cn/problems/making-a-large-island/description/)

# 十大经典排序算法

![](image\sort.png)

#### 为什么排序需要稳定？

- 排序算法的稳定性意味着对于具有相同关键字的元素， 排序后它们的相对顺序保持不变。在很多实际应用中， 我们需要保持数据中相等元素的顺序关系。 例如， 在排序员工工资的数据时， 如果有多名员工拥有相同的工资水平， 我们可能希望按照他们的入职时间来排序， 以维持他们在公司内部的先后顺序。 如果使用不稳定排序， 就可能打乱他们的相对顺序。  

## [快速排序（Quick Sort）](https://blog.csdn.net/qq_39181839/article/details/109478094)

### 介绍一下快速排序?

- 快速排序采用了**分治递归**的思想。 **快速排序的核心思想是选择一个基准元素， 通过将数组中的元素按照基准元素进行划分， 使得左侧的元素都小于基准元素， 右侧的元素都大于基准元素。** 然后对左右两个子数组分别进行递归排序， 直到整个数组有序。  
- 具体实现：如果选择第一个元素为基准元素，首先利用一个指针从数组右边开始寻找一个比基准元素小的元素，然后再利用一个指针从数组左边开始寻找一个比基准元素大的元素，最后将这两个元素进行交换，一直重复前面的过程直到左指针等于右指针，再将基准元素和左指针指向的元素进行交换。这样就得到一个左侧都是小于基准元素右侧都是大于基准元素的数组。然后分别递归左右两个子数组重复前面的过程，直到整个数组有序。
- 快速排序的平均时间复杂度是 O(nlogn)， 最坏时间复杂度是 O(n²)， 平均空间复杂度是 O(logn)，最坏空间复杂度是O(n)，是一种不稳定排序。  

#### 空间复杂度分析：

1. **递归调用栈的空间开销**： 快速排序使用递归来划分数组，**递归调用栈的深度决定了空间复杂度**。每次递归调用消耗的额外空间是递归栈的深度。
   - **平均情况**：如果每次划分都能将数组均匀地分为两部分，递归深度为 `log n`，因此空间复杂度是 **O(log n)**。
   - **最坏情况**：如果数组已经有序或几乎有序，快速排序每次划分只会减少一个元素，递归调用的深度会达到 `n`，此时空间复杂度为 **O(n)**。
2. **原地排序的空间开销**： 快速排序是一种**原地排序算法**，除了递归调用栈外，不需要额外的数组来存储数据。因此，除了递归栈之外，不需要额外的空间。

### 为什么快速排序最坏情况时间和空间复杂度会退化成 O(n²)  和O(n)?

- 最坏情况发生在待排序的序列**已经有序或近乎有序**的情况下。 在这种情况下， 如果每次选择的基准元素都是当前子数组的最大或最小值， 那么快速排序的分割过程将会非常不平衡，**导致递归树的高度接近于 n。**
- 在这种情况下， 每次划分只能将序列分成**一个空的子数组和一个包含 n-1 个元素的数组**， 而不是将序列均匀地分成两个大小相等的子数组。  

```java
/**
 * 快速排序实现升序排序
 * 在具体实现的时候，对于数据交换的时机有很多种选择
 * 
 * @param arr   待排序的数组
 * @param start 左指针
 * @param end   右指针
 */
public static void quickSort2(int[] arr, int start, int end) {
    if (start < end) {
        int base = arr[start], left = start, right = end;
        while (left < right) {
            //要保证右边的比基准元素大
            while (left < right && arr[right] >= base)
                right--;
            //要保证左边的比基准元素小
            while (left < right && arr[left] <= base)
                left++;
            if (left < right)
            	swap(arr, left, right);
        }
        //此时left==right
        swap(arr, start, left);
        quickSort2(arr, start, left - 1);
        quickSort2(arr, left + 1, end);
    }
}
```

